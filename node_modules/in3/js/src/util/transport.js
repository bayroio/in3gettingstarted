"use strict";
/***********************************************************
* This file is part of the Slock.it IoT Layer.             *
* The Slock.it IoT Layer contains:                         *
*   - USN (Universal Sharing Network)                      *
*   - INCUBED (Trustless INcentivized remote Node Network) *
************************************************************
* Copyright (C) 2016 - 2018 Slock.it GmbH                  *
* All Rights Reserved.                                     *
************************************************************
* You may use, distribute and modify this code under the   *
* terms of the license contract you have concluded with    *
* Slock.it GmbH.                                           *
* For information about liability, maintenance etc. also   *
* refer to the contract concluded with Slock.it GmbH.      *
************************************************************
* For more information, please refer to https://slock.it    *
* For questions, please contact info@slock.it              *
***********************************************************/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const cbor = require("../util/cbor");
/**
 * Default Transport impl sending http-requests.
 */
class AxiosTransport {
    constructor(format = 'json') {
        this.format = format;
    }
    isOnline() {
        return axios_1.default.head('https://www.google.com').then(_ => true, _ => false);
    }
    handle(url, data, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            // convertto array
            const requests = Array.isArray(data) ? data : [data];
            // add cbor-config
            const conf = { headers: { 'Content-Type': 'application/json' } };
            if (this.format === 'cbor')
                Object.assign(conf, {
                    transformRequest: cbor.encodeRequests,
                    transformResponse: cbor.decodeResponses,
                    headers: { 'Content-Type': 'application/cbor' },
                    responseType: 'arraybuffer'
                });
            // execute request
            try {
                //     requests.forEach(r=>console.log(' => req '+r.method+'('+r.params.map(_=>JSON.stringify(_)).join()+')'))
                const res = yield axios_1.default.post(url, requests, Object.assign({}, conf, { timeout: timeout || 5000 }));
                // throw if the status is an error
                if (res.status > 200)
                    throw new Error('Invalid status');
                // if this was not given as array, we need to convert it back to a single object
                return Array.isArray(data) ? res.data : res.data[0];
            }
            catch (err) {
                throw new Error('Invalid response from ' + url + '(' + JSON.stringify(requests, null, 2) + ')' + ' : ' + err.message + (err.response ? (err.response.data || err.response.statusText) : ''));
            }
        });
    }
    random(count) {
        const result = [];
        for (let i = 0; i < count; i++)
            result.push(Math.random());
        return result;
    }
}
exports.AxiosTransport = AxiosTransport;
//# sourceMappingURL=transport.js.map