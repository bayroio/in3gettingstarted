"use strict";
/***********************************************************
* This file is part of the Slock.it IoT Layer.             *
* The Slock.it IoT Layer contains:                         *
*   - USN (Universal Sharing Network)                      *
*   - INCUBED (Trustless INcentivized remote Node Network) *
************************************************************
* Copyright (C) 2016 - 2018 Slock.it GmbH                  *
* All Rights Reserved.                                     *
************************************************************
* You may use, distribute and modify this code under the   *
* terms of the license contract you have concluded with    *
* Slock.it GmbH.                                           *
* For information about liability, maintenance etc. also   *
* refer to the contract concluded with Slock.it GmbH.      *
************************************************************
* For more information, please refer to https://slock.it   *
* For questions, please contact info@slock.it              *
***********************************************************/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_util_1 = require("ethereumjs-util");
const util_1 = require("../../util/util");
const api_1 = require("./api");
function callContract(client, contract, chainId, signature, args, config) {
    return __awaiter(this, void 0, void 0, function* () {
        return api_1.decodeFunction(signature, yield client.sendRPC('eth_call', [{
                to: contract,
                data: '0x' + api_1.encodeFunction(signature, args)
            },
            'latest'], chainId, config)
            .then(_ => (_.error ? Promise.reject(new Error('Error handling call to ' + contract + ' :' + JSON.stringify(_.error))) : ethereumjs_util_1.toBuffer(_.result + ''))));
    });
}
exports.callContract = callContract;
function getChainData(client, chainId, config) {
    return __awaiter(this, void 0, void 0, function* () {
        return callContract(client, client.defConfig.chainRegistry, client.defConfig.mainChain, 'chains(bytes32):(address,string,string,address,bytes32)', [util_1.toHex(chainId, 32)], config).then(_ => ({
            owner: ethereumjs_util_1.toChecksumAddress(_[0]),
            bootNodes: _[1].split(','),
            meta: _[2],
            registryContract: ethereumjs_util_1.toChecksumAddress(_[3]),
            contractChain: util_1.toSimpleHex(util_1.toHex(_[4]))
        }));
    });
}
exports.getChainData = getChainData;
//# sourceMappingURL=chainData.js.map