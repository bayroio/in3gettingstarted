"use strict";
/***********************************************************
* This file is part of the Slock.it IoT Layer.             *
* The Slock.it IoT Layer contains:                         *
*   - USN (Universal Sharing Network)                      *
*   - INCUBED (Trustless INcentivized remote Node Network) *
************************************************************
* Copyright (C) 2016 - 2018 Slock.it GmbH                  *
* All Rights Reserved.                                     *
************************************************************
* You may use, distribute and modify this code under the   *
* terms of the license contract you have concluded with    *
* Slock.it GmbH.                                           *
* For information about liability, maintenance etc. also   *
* refer to the contract concluded with Slock.it GmbH.      *
************************************************************
* For more information, please refer to https://slock.it   *
* For questions, please contact info@slock.it              *
***********************************************************/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../../util/util");
class Filters {
    constructor() {
        this.filters = {};
    }
    addFilter(client, type, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type === 'pending')
                throw new Error('Pending Transactions are not supported');
            const id = '0x' + (Object.keys(this.filters).reduce((a, b) => Math.max(a, parseInt(b)), 0) + 1).toString(16);
            this.filters[id] = { type, options, lastBlock: parseInt(yield client.call('eth_blockNumber', [])) };
            return id;
        });
    }
    handleIntern(request, client) {
        switch (request.method) {
            case 'eth_newFilter':
                return this.addFilter(client, 'event', request.params[0])
                    .then(result => ({
                    id: request.id,
                    jsonrpc: request.jsonrpc,
                    result
                }));
            case 'eth_newBlockFilter':
                return this.addFilter(client, 'block', {})
                    .then(result => ({
                    id: request.id,
                    jsonrpc: request.jsonrpc,
                    result
                }));
            case 'eth_newPendingTransactionFilter':
                return this.addFilter(client, 'pending', {})
                    .then(result => ({
                    id: request.id,
                    jsonrpc: request.jsonrpc,
                    result
                }));
            case 'eth_uninstallFilter':
                return Promise.resolve({
                    id: request.id,
                    jsonrpc: request.jsonrpc,
                    result: !!this.removeFilter(request.params[0])
                });
            case 'eth_getFilterChanges':
                return this.getFilterChanges(client, request.params[0])
                    .then(result => ({
                    id: request.id,
                    jsonrpc: request.jsonrpc,
                    result
                }));
            default:
                return null;
        }
    }
    getFilterChanges(client, id) {
        return __awaiter(this, void 0, void 0, function* () {
            const filter = this.filters[id];
            if (!filter)
                throw new Error('Filter with id ' + id + ' not found!');
            if (filter.type === 'event') {
                const [blockNumber, logs] = yield client.send([
                    {
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'eth_blockNumber',
                        params: []
                    },
                    {
                        jsonrpc: '2.0',
                        id: 2,
                        method: 'eth_getLogs',
                        params: [Object.assign({}, filter.options, { fromBlock: '0x' + filter.lastBlock.toString(16) })]
                    }
                ])
                    .then(all => all[1].result ? all : [all[0], { result: [] }])
                    .then(util_1.checkForError)
                    .then(all => [parseInt(all[0].result), all[1].result]);
                filter.lastBlock = blockNumber + 1;
                return logs;
            }
            else if (filter.type === 'block') {
                const bN = parseInt(yield client.call('eth_blockNumber', []));
                if (bN > filter.lastBlock) {
                    const requests = [];
                    for (let i = filter.lastBlock + 1; i <= bN; i++)
                        requests.push({
                            jsonrpc: '2.0',
                            id: requests.length + 1,
                            method: 'eth_getBlockByNumber',
                            params: ['0x' + i.toString(16), false]
                        });
                    filter.lastBlock = bN;
                    return client.send(requests).then(r => r.map(_ => _.result.hash));
                }
                return [];
            }
        });
    }
    removeFilter(id) {
        const res = !!this.filters[id];
        delete this.filters[id];
        return res;
    }
}
exports.default = Filters;
//# sourceMappingURL=filter.js.map