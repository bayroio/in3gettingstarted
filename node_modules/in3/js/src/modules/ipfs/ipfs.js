"use strict";
/***********************************************************
* This file is part of the Slock.it IoT Layer.             *
* The Slock.it IoT Layer contains:                         *
*   - USN (Universal Sharing Network)                      *
*   - INCUBED (Trustless INcentivized remote Node Network) *
************************************************************
* Copyright (C) 2016 - 2018 Slock.it GmbH                  *
* All Rights Reserved.                                     *
************************************************************
* You may use, distribute and modify this code under the   *
* terms of the license contract you have concluded with    *
* Slock.it GmbH.                                           *
* For information about liability, maintenance etc. also   *
* refer to the contract concluded with Slock.it GmbH.      *
************************************************************
* For more information, please refer to https://slock.it   *
* For questions, please contact info@slock.it              *
***********************************************************/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const protons = require("protons");
const multihashing = require("multihashing-async");
const bs58 = require("bs58");
const proto = protons(`
message Data {
  enum DataType {
    Raw = 0;
    Directory = 1;
    File = 2;
    Metadata = 3;
    Symlink = 4;
    HAMTShard = 5;
  }

  required DataType Type = 1;
  optional bytes Data = 2;
  optional uint64 filesize = 3;
  repeated uint64 blocksizes = 4;

  optional uint64 hashType = 5;
  optional uint64 fanout = 6;
}

message PBLink {
  optional bytes Hash = 1;
  optional string Name = 2;
  optional uint64 Tsize = 3;
}

// An IPFS MerkleDAG Node
message PBNode {
  repeated PBLink Links = 2;
  optional bytes Data = 1;
}
`);
/**
 * creates a IPFS-Hash from content
 * @param content
 */
function createIPFSHash(content, hashAlg = 'sha2-256') {
    return new Promise((resolve, reject) => {
        // serialize content
        const serialized = proto.PBNode.encode({
            Data: proto.Data.encode({
                Type: proto.Data.DataType.File,
                Data: content,
                filesize: content.length
            }), Links: null
        });
        multihashing(serialized, hashAlg, (err, multihash) => {
            if (err)
                return reject(err);
            resolve(bs58.encode(multihash));
        });
    });
}
exports.createIPFSHash = createIPFSHash;
function verifyIPFSHash(content, encoding, requestedHash) {
    return __awaiter(this, void 0, void 0, function* () {
        let reponseHash;
        try {
            reponseHash = yield createIPFSHash(Buffer.isBuffer(content) ? content : Buffer.from(content, encoding));
        }
        catch (er) {
            // TODO onlx in the react-native package he is not able to calculate the hash and throws, for now we ignore it, but we should find a solution to make it work there as well.
            return true;
        }
        if (reponseHash !== requestedHash)
            throw new Error('The content verification failed, because the IPFS-Hash is wrong');
        return true;
    });
}
exports.verifyIPFSHash = verifyIPFSHash;
//# sourceMappingURL=ipfs.js.map