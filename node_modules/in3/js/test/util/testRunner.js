"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Client_1 = require("../../src/client/Client");
const util_1 = require("../../src/util/util");
const fs_1 = require("fs");
const ignoreFuxxProps = ['id', 'error', 'currentBlock', 'execTime', 'lastNodeList', 'totalDifficulty', 'size', 'chainId', 'transactionLogIndex', 'logIndex', 'lastValidatorChange'];
const ignoreTxProps = ['from', 'blockHash', 'blockNumber', 'publicKey', 'raw', 'standardV', 'transactionIndex'];
const defaultConfig = require('../../src/client/defaultConfig.json');
function runFuzzTests(filter, test, allResults, c, ob, prefix = '') {
    return __awaiter(this, void 0, void 0, function* () {
        if (!ob)
            return c;
        for (const k of Object.keys(ob).filter(_ => _ && ignoreFuxxProps.indexOf(_) < 0 && (prefix.indexOf('proof.transactions') < 0 || ignoreTxProps.indexOf(_) < 0))) {
            const val = ob[k];
            if (typeof val === 'string') {
                if (val.startsWith('0x')) {
                    if (val.length == 2)
                        ob[k] = '0x01';
                    else if (val[2] === '9')
                        ob[k] = '0xa' + val.substr(3);
                    else if (val[2].toLowerCase() === 'f')
                        ob[k] = '0x0' + val.substr(3);
                    else
                        ob[k] = '0x' + String.fromCharCode(val[2].charCodeAt(0) + 1) + val.substr(3);
                }
                else
                    continue;
            }
            else if (typeof val === 'number')
                ob[k] = val + 1;
            else if (Array.isArray(val)) {
                if (val[0] && typeof val[0] === 'object')
                    c = yield runFuzzTests(filter, test, allResults, c, val[0], prefix + '.' + k);
                continue;
            }
            else if (typeof val === 'object') {
                c = yield runFuzzTests(filter, test, allResults, c, val, prefix + '.' + k);
                continue;
            }
            else
                continue;
            c++;
            if (filter < 0 || c == filter) {
                test.success = false;
                const result = yield runSingleTest(test, c);
                test.success = true;
                allResults.push(result);
                console.log(addSpace('' + result.c, 3) + ' : ' + addSpace('  ' + prefix + '.' + k, 85, '.', result.success ? '' : '31') + ' ' + addSpace(result.success ? 'OK' : result.error, 0, ' ', result.success ? '32' : '31'));
            }
            ob[k] = val;
        }
        return c;
    });
}
function run_test(files, filter) {
    return __awaiter(this, void 0, void 0, function* () {
        const allResults = [];
        let c = 0;
        for (const file of files) {
            for (const test of JSON.parse(fs_1.readFileSync(file, 'utf8'))) {
                c++;
                if (filter < 0 || c == filter) {
                    const result = yield runSingleTest(test, c);
                    allResults.push(result);
                    console.log(addSpace('' + result.c, 3) + ' : ' + addSpace(result.descr, 85, '.', result.success ? '' : '31') + ' ' + addSpace(result.success ? 'OK' : result.error, 0, ' ', result.success ? '32' : '31'));
                }
                if (test.fuzzer)
                    c = yield runFuzzTests(filter, test, allResults, c, test.response[0]);
            }
        }
        return allResults;
    });
}
exports.run_test = run_test;
function runSingleTest(test, c) {
    return __awaiter(this, void 0, void 0, function* () {
        test = JSON.parse(JSON.stringify(test));
        let res = 0;
        const config = test.config || {}, result = { descr: test.descr, c, success: false, error: undefined };
        const client = new Client_1.default({
            requestCount: config.requestCount || 1,
            includeCode: true,
            proof: test.proof || 'standard',
            chainId: test.chainId || '0x1',
            autoUpdateList: false,
            maxAttempts: 1,
            loggerUrl: ''
        }, {
            handle(url, data, timeout) {
                if (data[0].method == 'in3_validatorlist') {
                    const response = JSON.parse(fs_1.readFileSync(process.cwd() + '/test/util/in3_validatorlist_' + test.chainId + '.json', 'utf8').toString());
                    const validatorResponse = mockValidatorList(response, data[0].params);
                    validatorResponse.id = data[0].id;
                    validatorResponse.jsonrpc = data[0].jsonrpc;
                    return Promise.resolve([validatorResponse]);
                }
                test.response[res].id = data[0].id;
                return Promise.resolve([test.response[res++]]);
            },
            isOnline() {
                return Promise.resolve(true);
            },
            random(count) {
                const r = [];
                for (let i = 0; i < count; i++)
                    r[i] = i / count;
                return r;
            }
        });
        for (const chainId of Object.keys(client.defConfig.servers))
            client.defConfig.servers[chainId].needsUpdate = false;
        client.defConfig.servers[client.defConfig.chainId].weights = {};
        if (test.signatures)
            client.defConfig.signatureCount = test.signatures.length;
        //quick hack for validatorProof verification - Magic Code
        if (client.defConfig.chainId === '0x44d') {
            const ctx = client.getChainContext('0x44d');
            ctx.lastValidatorChange = 1216963;
        }
        //quick hack for transitioned POA verification - Magic Code
        if (client.defConfig.chainId === '0x2a') {
            const ctx = client.getChainContext('0x2a');
            ctx.lastValidatorChange = 10994697;
        }
        let s = false, error = null;
        try {
            const response = yield client.send(test.request);
            s = !!(response && response.result);
        }
        catch (err) {
            error = err;
        }
        if (s === (test.success == undefined ? true : test.success))
            result.success = true;
        else
            result.error = s ? 'Should have failed' : (error && error.message) || 'Failed';
        return result;
    });
}
function mockValidatorList(response, params) {
    const states = response.result.states;
    const startIndex = (params && params.length > 0) ? util_1.toNumber(params[0]) : 0;
    const limit = (params && params.length > 1) ? util_1.toNumber(params[1]) : 2;
    return {
        id: 0,
        result: {
            states: limit ? response.result.states.slice(startIndex, startIndex + limit + 1) : response.result.states.slice(startIndex),
            lastCheckedBlock: response.result.lastCheckedBlock
        },
        jsonrpc: '2.0',
        in3: response.in3
    };
}
function addSpace(s, l, filler = ' ', color = '') {
    while (s.length < l)
        s += filler;
    return color ? '\x1B[' + color + 'm' + s + '\x1B[0m' : s;
}
//# sourceMappingURL=testRunner.js.map